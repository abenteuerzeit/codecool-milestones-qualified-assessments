/*
What is Unit Testing?

It's a software design pattern

It's a programming paradigm

It's a software testing technique

It's a software development framework

2.
What does TDD stand for?

Test Driven Design

Test Driven Development

Test Data Domain

Test Data Development

3.
What is NUnit?

It's a programming language for writing unit tests

It's a C# framework for writing unit tests

It's a language-agnostic framework for writing unit tests

It's a visual tool for testing software

4.
What is the [TestFixture] attribute used for?

It's used for marking classes containing tests

It's used for marking test methods

It's used for marking classes, that will be tested

It's used for marking methods, that will be tested

5.
What is the [Test] attribute used for?

It's used for marking classes containing tests

It's used for marking test methods

It's used for marking classes, that will be tested

It's used for marking methods, that will be tested

6.
What is the [TestCase] attribute used for?

It's used for marking test methods

It's used for marking methods, that will be tested

It's used for defining multiple usages of the same test class, but with different parameters

It's used for defining multiple usages of the same test method, but with different parameters

7.
What is the [SetUp] attribute used for?

It's used for marking the test class's constructor

It's used for marking the tested class's constructor

It's used for marking a method that executes before running the tests

It's used for marking a method that executes before each test is run

8.
What is the [TearDown] attribute used for?

It's used for marking the test class's destructor

It's used for marking the tested class's destructor

It's used for marking a method that executes after each test is run

It's used for marking a method that executes after all tests have been run

9.
Which one is NOT a valid test outcome?

Ignored

Skipped

Inconclusive

Unsupported

10.
You have two List<int> objects: expectedList and actualList. You want to test whether the two lists contain the same elements, regardless of their order.

Which testing method you should use?

Assert.AreEqual(expectedList, actualList)

Assert.AreSame(expectedList, actualList)

CollectionAssert.AreEqual(expectedList, actualList)

CollectionAssert.AreEquivalent(expectedList, actualList)
*/